<!DOCTYPE html><html lang="en" mode="dark" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="theme" content="Chirpy v2.5.1"><meta name="generator" content="Jekyll v4.3.2" /><meta property="og:title" content="Integration Tests" /><meta name="author" content="Shawn" /><meta property="og:locale" content="en_US" /><meta name="description" content="Integration Tests, in contrast to Unit Tests, test the behavior of more than one unit of our code when working together. This may be as simple as testing two classes interacting together, or we might bootstrap most of our application to be tested. In fact, some of the most useful types of Integration Tests are designed to test as much of our codebase as possible while still isolating it from external dependencies, such as third party APIs, the filesystem, or databases. Below is an example Integration Test: A useful way of conceptualizing a large-scale Integration Test is by considering a single application with a layered architecture, with each layer in the stack having its own type of responsibility: In the above example, we will wire up the real implementation of classes in our stack from the top of the stack, all the way down as close to the bottom as we can get while still abstracting away external dependencies. Ideally we will have a clean interface to consume which handles communication with our external dependencies, such as a class in a third party library. But we are not always so lucky, and in this case we can use mocked versions of our interfaces that represent the Data Access Layer, which is responsible for reading and writing data to our external dependencies. Purpose of Integration Tests Due to their larger scope, Integration Tests are more complex to set up than Unit Tests, yet they test things which cannot be tested by Unit Tests. Unit Tests assert the correct behavior of a single unit of code in isolation, but Integration Tests help us ensure that they behave correctly when working together. As an example, imagine that we have two classes, UriHelper and FooBar which interact, and a test asserting that when FooBar‘s UriHasHostName method is passed a null URI, it will return false. 1 2 3 4 5 6 7 8 9 10 11 12 public class FooBar { private UriHelper _myDependency; public FooBar(UriHelper myDependency) { _myDependency = myDependency; } public bool UriHasHostName(string uri, string hostName) { return _myDependency.GetHostName(uri).Contains(hostName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class UriHelper { public string GetHostName(string input) { Uri uri; var succeeded = Uri.TryCreate(input, UriKind.Absolute, out uri); if (succeeded) { return uri.Host; } else { return null; } } } 1 2 3 4 5 6 7 [Fact] public void UriHasHostName_PassedInvalidUri_ReturnsFalse() { var sut = new FooBar(new UriHelper()); var result = sut.UriHasHostName(&quot;blah&quot;, &quot;google.com&quot;); Assert.False(result); } Did you spot the bug? Instead of passing, our test throws an exception on line 5. While the behavior of both classes might be considered correct in isolation, the way FooBar consumes the return value from UriHelper‘s GetHostName method is invalid and leads to a NullReferenceException at runtime. Because GetHostName returns null when it is provided an invalid URI, and FooBar does not properly check for null responses, these two classes (despite their implementations being potentially valid in isolation) cause a runtime failure. Bugs like this, where the interactions between two classes in our codebase are built upon faulty assumptions, are the sorts of bugs that we can identify and protect from using Integration tests. Thinking Bigger The previous test was useful to illustrate a faulty interaction between two classes, but what if we want to test our entire codebase? Writing some happy path tests that assert that our codebase can function correctly in some common use-cases can be an excellent guard against a wide variety of regression bugs in our codebase. For this example, let’s create a new ASP.NET Core web application in Visual Studio, then add an XUnit test project to the solution: Next, let’s add a reference from our XUnit project to our webapp: Next, let’s add a reference to the Microsoft.AspNetCore.Mvc.Testing NuGet package in our Test project: This package contains useful tools for designing Integration tests like the one in this example. In particular, it contains the WebApplicationFactory class which can be used to bootstrap an in-memory instance of our web application, along with a client that can be used to route HTTP requests to it over the loopback. The WebApplicationFactory constructor accepts a generic type argument, which is the type of the Startup class which will be used to bootstrap our web application. A trivial test using this class looks as follows: 1 2 3 4 5 6 7 8 [Fact] public async Task GetAsync_Index_ReturnsSuccess() { var factory = new WebApplicationFactory&lt;Startup&gt;(); var sut = factory.CreateClient(); var response = await sut.GetAsync(&quot;/Index&quot;); response.EnsureSuccessStatusCode(); } Once we have written this test, we can then test that it works by setting breakpoints in either the Startup class or in the codebehind for the Index path (Index.cshtml.cs) Then we can run the test in our debugger and see that our breakpoints are hit: Because our current implementation has no external dependencies, this can already be considered an Integration Test. However as we expand our application’s logic, we will likely take on external dependencies. How do we mock them? The most straightforward way is to provide a second test double implementation of our Startup class which provides mocked versions of our external dependencies to the DI container in its ConfigureServices method, while using the live implementation of all of our classes which do not directly interact with external dependencies: 1 var factory = new WebApplicationFactory&lt;IntegrationTestStartup&gt;(); If you are working on a .NET codebase and are interested in more details about integration testing, Microsoft has some good documentation on the topic. Why We Mock Our Dependencies While it is possible to design large-scale tests such as these without mocking our external dependencies which makes them more realistic, those would be considered System Tests and have two major drawbacks which Integration Tests do not: They are generally much slower due to depending on slow operations like network I/O, and hard disk or database access. They can fail due to problems outside of our codebase, which makes them unsuitable for use as quality gates during our build process – we don’t want our build to fail just because a third party API is having a bad day! Both Integration and System Tests have their place, but one of the major strengths of Integration Tests is that they are the most complete way to exercise our codebase while still having their result be solely dependent upon the contents of our codebase." /><meta property="og:description" content="Integration Tests, in contrast to Unit Tests, test the behavior of more than one unit of our code when working together. This may be as simple as testing two classes interacting together, or we might bootstrap most of our application to be tested. In fact, some of the most useful types of Integration Tests are designed to test as much of our codebase as possible while still isolating it from external dependencies, such as third party APIs, the filesystem, or databases. Below is an example Integration Test: A useful way of conceptualizing a large-scale Integration Test is by considering a single application with a layered architecture, with each layer in the stack having its own type of responsibility: In the above example, we will wire up the real implementation of classes in our stack from the top of the stack, all the way down as close to the bottom as we can get while still abstracting away external dependencies. Ideally we will have a clean interface to consume which handles communication with our external dependencies, such as a class in a third party library. But we are not always so lucky, and in this case we can use mocked versions of our interfaces that represent the Data Access Layer, which is responsible for reading and writing data to our external dependencies. Purpose of Integration Tests Due to their larger scope, Integration Tests are more complex to set up than Unit Tests, yet they test things which cannot be tested by Unit Tests. Unit Tests assert the correct behavior of a single unit of code in isolation, but Integration Tests help us ensure that they behave correctly when working together. As an example, imagine that we have two classes, UriHelper and FooBar which interact, and a test asserting that when FooBar‘s UriHasHostName method is passed a null URI, it will return false. 1 2 3 4 5 6 7 8 9 10 11 12 public class FooBar { private UriHelper _myDependency; public FooBar(UriHelper myDependency) { _myDependency = myDependency; } public bool UriHasHostName(string uri, string hostName) { return _myDependency.GetHostName(uri).Contains(hostName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class UriHelper { public string GetHostName(string input) { Uri uri; var succeeded = Uri.TryCreate(input, UriKind.Absolute, out uri); if (succeeded) { return uri.Host; } else { return null; } } } 1 2 3 4 5 6 7 [Fact] public void UriHasHostName_PassedInvalidUri_ReturnsFalse() { var sut = new FooBar(new UriHelper()); var result = sut.UriHasHostName(&quot;blah&quot;, &quot;google.com&quot;); Assert.False(result); } Did you spot the bug? Instead of passing, our test throws an exception on line 5. While the behavior of both classes might be considered correct in isolation, the way FooBar consumes the return value from UriHelper‘s GetHostName method is invalid and leads to a NullReferenceException at runtime. Because GetHostName returns null when it is provided an invalid URI, and FooBar does not properly check for null responses, these two classes (despite their implementations being potentially valid in isolation) cause a runtime failure. Bugs like this, where the interactions between two classes in our codebase are built upon faulty assumptions, are the sorts of bugs that we can identify and protect from using Integration tests. Thinking Bigger The previous test was useful to illustrate a faulty interaction between two classes, but what if we want to test our entire codebase? Writing some happy path tests that assert that our codebase can function correctly in some common use-cases can be an excellent guard against a wide variety of regression bugs in our codebase. For this example, let’s create a new ASP.NET Core web application in Visual Studio, then add an XUnit test project to the solution: Next, let’s add a reference from our XUnit project to our webapp: Next, let’s add a reference to the Microsoft.AspNetCore.Mvc.Testing NuGet package in our Test project: This package contains useful tools for designing Integration tests like the one in this example. In particular, it contains the WebApplicationFactory class which can be used to bootstrap an in-memory instance of our web application, along with a client that can be used to route HTTP requests to it over the loopback. The WebApplicationFactory constructor accepts a generic type argument, which is the type of the Startup class which will be used to bootstrap our web application. A trivial test using this class looks as follows: 1 2 3 4 5 6 7 8 [Fact] public async Task GetAsync_Index_ReturnsSuccess() { var factory = new WebApplicationFactory&lt;Startup&gt;(); var sut = factory.CreateClient(); var response = await sut.GetAsync(&quot;/Index&quot;); response.EnsureSuccessStatusCode(); } Once we have written this test, we can then test that it works by setting breakpoints in either the Startup class or in the codebehind for the Index path (Index.cshtml.cs) Then we can run the test in our debugger and see that our breakpoints are hit: Because our current implementation has no external dependencies, this can already be considered an Integration Test. However as we expand our application’s logic, we will likely take on external dependencies. How do we mock them? The most straightforward way is to provide a second test double implementation of our Startup class which provides mocked versions of our external dependencies to the DI container in its ConfigureServices method, while using the live implementation of all of our classes which do not directly interact with external dependencies: 1 var factory = new WebApplicationFactory&lt;IntegrationTestStartup&gt;(); If you are working on a .NET codebase and are interested in more details about integration testing, Microsoft has some good documentation on the topic. Why We Mock Our Dependencies While it is possible to design large-scale tests such as these without mocking our external dependencies which makes them more realistic, those would be considered System Tests and have two major drawbacks which Integration Tests do not: They are generally much slower due to depending on slow operations like network I/O, and hard disk or database access. They can fail due to problems outside of our codebase, which makes them unsuitable for use as quality gates during our build process – we don’t want our build to fail just because a third party API is having a bad day! Both Integration and System Tests have their place, but one of the major strengths of Integration Tests is that they are the most complete way to exercise our codebase while still having their result be solely dependent upon the contents of our codebase." /><link rel="canonical" href="https://dancerscode.com/posts/integration-tests/" /><meta property="og:url" content="https://dancerscode.com/posts/integration-tests/" /><meta property="og:site_name" content="Dancer’s Code" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2019-12-04T12:00:00-06:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Integration Tests" /><meta name="twitter:site" content="@TheDancersCode" /><meta name="twitter:creator" content="@Shawn" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://dancerscode.com/posts/integration-tests/"},"description":"Integration Tests, in contrast to Unit Tests, test the behavior of more than one unit of our code when working together. This may be as simple as testing two classes interacting together, or we might bootstrap most of our application to be tested. In fact, some of the most useful types of Integration Tests are designed to test as much of our codebase as possible while still isolating it from external dependencies, such as third party APIs, the filesystem, or databases. Below is an example Integration Test: A useful way of conceptualizing a large-scale Integration Test is by considering a single application with a layered architecture, with each layer in the stack having its own type of responsibility: In the above example, we will wire up the real implementation of classes in our stack from the top of the stack, all the way down as close to the bottom as we can get while still abstracting away external dependencies. Ideally we will have a clean interface to consume which handles communication with our external dependencies, such as a class in a third party library. But we are not always so lucky, and in this case we can use mocked versions of our interfaces that represent the Data Access Layer, which is responsible for reading and writing data to our external dependencies. Purpose of Integration Tests Due to their larger scope, Integration Tests are more complex to set up than Unit Tests, yet they test things which cannot be tested by Unit Tests. Unit Tests assert the correct behavior of a single unit of code in isolation, but Integration Tests help us ensure that they behave correctly when working together. As an example, imagine that we have two classes, UriHelper and FooBar which interact, and a test asserting that when FooBar‘s UriHasHostName method is passed a null URI, it will return false. 1 2 3 4 5 6 7 8 9 10 11 12 public class FooBar { private UriHelper _myDependency; public FooBar(UriHelper myDependency) { _myDependency = myDependency; } public bool UriHasHostName(string uri, string hostName) { return _myDependency.GetHostName(uri).Contains(hostName); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class UriHelper { public string GetHostName(string input) { Uri uri; var succeeded = Uri.TryCreate(input, UriKind.Absolute, out uri); if (succeeded) { return uri.Host; } else { return null; } } } 1 2 3 4 5 6 7 [Fact] public void UriHasHostName_PassedInvalidUri_ReturnsFalse() { var sut = new FooBar(new UriHelper()); var result = sut.UriHasHostName(&quot;blah&quot;, &quot;google.com&quot;); Assert.False(result); } Did you spot the bug? Instead of passing, our test throws an exception on line 5. While the behavior of both classes might be considered correct in isolation, the way FooBar consumes the return value from UriHelper‘s GetHostName method is invalid and leads to a NullReferenceException at runtime. Because GetHostName returns null when it is provided an invalid URI, and FooBar does not properly check for null responses, these two classes (despite their implementations being potentially valid in isolation) cause a runtime failure. Bugs like this, where the interactions between two classes in our codebase are built upon faulty assumptions, are the sorts of bugs that we can identify and protect from using Integration tests. Thinking Bigger The previous test was useful to illustrate a faulty interaction between two classes, but what if we want to test our entire codebase? Writing some happy path tests that assert that our codebase can function correctly in some common use-cases can be an excellent guard against a wide variety of regression bugs in our codebase. For this example, let’s create a new ASP.NET Core web application in Visual Studio, then add an XUnit test project to the solution: Next, let’s add a reference from our XUnit project to our webapp: Next, let’s add a reference to the Microsoft.AspNetCore.Mvc.Testing NuGet package in our Test project: This package contains useful tools for designing Integration tests like the one in this example. In particular, it contains the WebApplicationFactory class which can be used to bootstrap an in-memory instance of our web application, along with a client that can be used to route HTTP requests to it over the loopback. The WebApplicationFactory constructor accepts a generic type argument, which is the type of the Startup class which will be used to bootstrap our web application. A trivial test using this class looks as follows: 1 2 3 4 5 6 7 8 [Fact] public async Task GetAsync_Index_ReturnsSuccess() { var factory = new WebApplicationFactory&lt;Startup&gt;(); var sut = factory.CreateClient(); var response = await sut.GetAsync(&quot;/Index&quot;); response.EnsureSuccessStatusCode(); } Once we have written this test, we can then test that it works by setting breakpoints in either the Startup class or in the codebehind for the Index path (Index.cshtml.cs) Then we can run the test in our debugger and see that our breakpoints are hit: Because our current implementation has no external dependencies, this can already be considered an Integration Test. However as we expand our application’s logic, we will likely take on external dependencies. How do we mock them? The most straightforward way is to provide a second test double implementation of our Startup class which provides mocked versions of our external dependencies to the DI container in its ConfigureServices method, while using the live implementation of all of our classes which do not directly interact with external dependencies: 1 var factory = new WebApplicationFactory&lt;IntegrationTestStartup&gt;(); If you are working on a .NET codebase and are interested in more details about integration testing, Microsoft has some good documentation on the topic. Why We Mock Our Dependencies While it is possible to design large-scale tests such as these without mocking our external dependencies which makes them more realistic, those would be considered System Tests and have two major drawbacks which Integration Tests do not: They are generally much slower due to depending on slow operations like network I/O, and hard disk or database access. They can fail due to problems outside of our codebase, which makes them unsuitable for use as quality gates during our build process – we don’t want our build to fail just because a third party API is having a bad day! Both Integration and System Tests have their place, but one of the major strengths of Integration Tests is that they are the most complete way to exercise our codebase while still having their result be solely dependent upon the contents of our codebase.","url":"https://dancerscode.com/posts/integration-tests/","author":{"@type":"Person","name":"Shawn"},"headline":"Integration Tests","dateModified":"2019-12-04T12:00:00-06:00","datePublished":"2019-12-04T12:00:00-06:00","@context":"https://schema.org"}</script><title>Integration Tests | Dancer's Code</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="preload" as="style" href="/assets/css/post.css"><link rel="stylesheet" href="/assets/css/post.css"><link rel="preload" as="style" href="/assets/css/lib/bootstrap-toc.min.css"><link rel="stylesheet" href="/assets/css/lib/bootstrap-toc.min.css" /> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="/assets/js/post.min.js"></script> <script defer src="/app.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column"><div id="nav-wrapper"><div id="profile-wrapper" class="d-flex flex-column"><div id="avatar" class="d-flex justify-content-center"> <a href="/" alt="avatar"> <img src="/assets/img/dancers-code-logo.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="profile-text mt-3"><div class="site-title"> <a href="/">Dancer's Code</a></div><div class="site-subtitle font-italic">Code should be elegant, too.</div></div></div><ul class="nav flex-column"><li class="nav-item d-flex justify-content-center "> <a href="/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/categories/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/tags/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/archives/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item d-flex justify-content-center "> <a href="/tabs/about/" class="nav-link d-flex justify-content-center align-items-center w-100"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul></div><div class="sidebar-bottom d-flex flex-wrap justify-content-around mt-4"> <a href="https://github.com/JessieArr" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/TheDancersCode" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>Integration Tests</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Integration Tests</h1><div class="post-meta text-muted d-flex flex-column"><div> Posted <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 4, 2019, 12:00 PM -0600" > Dec 4, 2019 <i class="unloaded">2019-12-04T12:00:00-06:00</i> </span> by <span class="author"> Shawn </span></div><div> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Dec 1, 2020, 1:16 AM -0600" > Dec 1, 2020 <i class="unloaded">2020-12-01T01:16:45-06:00</i> </span></div></div><div class="post-content"><p>Integration Tests, in contrast to Unit Tests, test the behavior of more than one unit of our code when working together. This may be as simple as testing two classes interacting together, or we might bootstrap most of our application to be tested. In fact, some of the most useful types of Integration Tests are designed to test as much of our codebase as possible while still isolating it from external dependencies, such as third party APIs, the filesystem, or databases.</p><p>Below is an example Integration Test:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/content/2019/integration-test-diagram.png" alt="Integration Test Diagram" /></p><p>A useful way of conceptualizing a large-scale Integration Test is by considering a single application with a layered architecture, with each layer in the stack having its own type of responsibility:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/content/2019/integration-test-diagram-2.png" alt="Integration Test Diagram" /></p><p>In the above example, we will wire up the real implementation of classes in our stack from the top of the stack, all the way down as close to the bottom as we can get while still abstracting away external dependencies. Ideally we will have a clean interface to consume which handles communication with our external dependencies, such as a class in a third party library. But we are not always so lucky, and in this case we can use mocked versions of our interfaces that represent the Data Access Layer, which is responsible for reading and writing data to our external dependencies.</p><h2 id="purpose-of-integration-tests">Purpose of Integration Tests</h2><p>Due to their larger scope, Integration Tests are more complex to set up than Unit Tests, yet they test things which cannot be tested by Unit Tests. Unit Tests assert the correct behavior of a single unit of code in isolation, but Integration Tests help us ensure that they behave correctly when working together. As an example, imagine that we have two classes, UriHelper and FooBar which interact, and a test asserting that when FooBar‘s UriHasHostName method is passed a null URI, it will return false.</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>    <span class="k">public</span> <span class="k">class</span> <span class="nc">FooBar</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="n">UriHelper</span> <span class="n">_myDependency</span><span class="p">;</span>
        <span class="k">public</span> <span class="nf">FooBar</span><span class="p">(</span><span class="n">UriHelper</span> <span class="n">myDependency</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_myDependency</span> <span class="p">=</span> <span class="n">myDependency</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">UriHasHostName</span><span class="p">(</span><span class="kt">string</span> <span class="n">uri</span><span class="p">,</span> <span class="kt">string</span> <span class="n">hostName</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">_myDependency</span><span class="p">.</span><span class="nf">GetHostName</span><span class="p">(</span><span class="n">uri</span><span class="p">).</span><span class="nf">Contains</span><span class="p">(</span><span class="n">hostName</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>    <span class="k">public</span> <span class="k">class</span> <span class="nc">UriHelper</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="nf">GetHostName</span><span class="p">(</span><span class="kt">string</span> <span class="n">input</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Uri</span> <span class="n">uri</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">succeeded</span> <span class="p">=</span> <span class="n">Uri</span><span class="p">.</span><span class="nf">TryCreate</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="n">UriKind</span><span class="p">.</span><span class="n">Absolute</span><span class="p">,</span> <span class="k">out</span> <span class="n">uri</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">succeeded</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">uri</span><span class="p">.</span><span class="n">Host</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></table></code></div></div><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">UriHasHostName_PassedInvalidUri_ReturnsFalse</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">FooBar</span><span class="p">(</span><span class="k">new</span> <span class="nf">UriHelper</span><span class="p">());</span>
        <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="n">sut</span><span class="p">.</span><span class="nf">UriHasHostName</span><span class="p">(</span><span class="s">"blah"</span><span class="p">,</span> <span class="s">"google.com"</span><span class="p">);</span>
        <span class="n">Assert</span><span class="p">.</span><span class="nf">False</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>Did you spot the bug?</p><p>Instead of passing, our test throws an exception on line 5. While the behavior of both classes might be considered correct in isolation, the way FooBar consumes the return value from UriHelper‘s GetHostName method is invalid and leads to a NullReferenceException at runtime. Because GetHostName returns null when it is provided an invalid URI, and FooBar does not properly check for null responses, these two classes (despite their implementations being potentially valid in isolation) cause a runtime failure.</p><p>Bugs like this, where the interactions between two classes in our codebase are built upon faulty assumptions, are the sorts of bugs that we can identify and protect from using Integration tests.</p><h2 id="thinking-bigger">Thinking Bigger</h2><p>The previous test was useful to illustrate a faulty interaction between two classes, but what if we want to test our entire codebase? Writing some <a href="https://en.wikipedia.org/wiki/Happy_path">happy path</a> tests that assert that our codebase can function correctly in some common use-cases can be an excellent guard against a wide variety of regression bugs in our codebase.</p><p>For this example, let’s create a new ASP.NET Core web application in Visual Studio, then add an XUnit test project to the solution:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/content/2019/new-asp-net-core-web-app.png" alt="Integration Test Diagram" /></p><p>Next, let’s add a reference from our XUnit project to our webapp:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/content/2019/xunit-reference.png" alt="Integration Test Diagram" /></p><p>Next, let’s add a reference to the Microsoft.AspNetCore.Mvc.Testing NuGet package in our Test project:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/content/2019/integration-testing-reference.png" alt="Integration Test Diagram" /></p><p>This package contains useful tools for designing Integration tests like the one in this example. In particular, it contains the WebApplicationFactory class which can be used to bootstrap an in-memory instance of our web application, along with a client that can be used to route HTTP requests to it over the loopback. The WebApplicationFactory constructor accepts a generic type argument, which is the type of the Startup class which will be used to bootstrap our web application. A trivial test using this class looks as follows:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>    <span class="p">[</span><span class="n">Fact</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span> <span class="nf">GetAsync_Index_ReturnsSuccess</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">factory</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebApplicationFactory</span><span class="p">&lt;</span><span class="n">Startup</span><span class="p">&gt;();</span>
        <span class="kt">var</span> <span class="n">sut</span> <span class="p">=</span> <span class="n">factory</span><span class="p">.</span><span class="nf">CreateClient</span><span class="p">();</span>
        <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="k">await</span> <span class="n">sut</span><span class="p">.</span><span class="nf">GetAsync</span><span class="p">(</span><span class="s">"/Index"</span><span class="p">);</span>
        <span class="n">response</span><span class="p">.</span><span class="nf">EnsureSuccessStatusCode</span><span class="p">();</span>
    <span class="p">}</span>
</pre></table></code></div></div><p>Once we have written this test, we can then test that it works by setting breakpoints in either the Startup class or in the codebehind for the Index path (Index.cshtml.cs) Then we can run the test in our debugger and see that our breakpoints are hit:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 " data-src="/content/2019/integration-test-breakpoint.png" alt="Integration Test Diagram" /></p><p>Because our current implementation has no external dependencies, this can already be considered an Integration Test. However as we expand our application’s logic, we will likely take on external dependencies. How do we mock them?</p><p>The most straightforward way is to provide a second test double implementation of our Startup class which provides mocked versions of our external dependencies to the DI container in its ConfigureServices method, while using the live implementation of all of our classes which do not directly interact with external dependencies:</p><div class="language-c# highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">var</span> <span class="n">factory</span> <span class="p">=</span> <span class="k">new</span> <span class="n">WebApplicationFactory</span><span class="p">&lt;</span><span class="n">IntegrationTestStartup</span><span class="p">&gt;();</span>
</pre></table></code></div></div><p>If you are working on a .NET codebase and are interested in more details about integration testing, Microsoft has some good documentation on the topic.</p><h2 id="why-we-mock-our-dependencies">Why We Mock Our Dependencies</h2><p>While it is possible to design large-scale tests such as these without mocking our external dependencies which makes them more realistic, those would be considered System Tests and have two major drawbacks which Integration Tests do not:</p><ol><li>They are generally much slower due to depending on slow operations like network I/O, and hard disk or database access.<li>They can fail due to problems outside of our codebase, which makes them unsuitable for use as quality gates during our build process – we don’t want our build to fail just because a third party API is having a bad day!</ol><p>Both Integration and System Tests have their place, but one of the major strengths of Integration Tests is that they are the most complete way to exercise our codebase while still having their result be solely dependent upon the contents of our codebase.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/testing/'>Testing</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/testing/" class="post-tag no-text-decoration" >Testing</a> <a href="/tags/integration/" class="post-tag no-text-decoration" >Integration</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Integration Tests - Dancer's Code&url=https://dancerscode.com/posts/integration-tests/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Integration Tests - Dancer's Code&u=https://dancerscode.com/posts/integration-tests/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Integration Tests - Dancer's Code&url=https://dancerscode.com/posts/integration-tests/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/test-automation-strategy/">Test Automation Strategy</a><li><a href="/posts/new-blog-who-dis/">New Blog Who Dis??</a><li><a href="/posts/javascript-is-the-right-flavor-of-bad/">Javascript is the Right Flavor of Bad</a><li><a href="/posts/commonly-misused-programming-terms/">Commonly Misused Programming Terms</a><li><a href="/posts/thoughts-on-gitkraken/">Thoughts on GitKraken</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/automation/">Automation</a> <a class="post-tag" href="/tags/testing/">Testing</a> <a class="post-tag" href="/tags/blog/">Blog</a> <a class="post-tag" href="/tags/clean-code/">Clean Code</a> <a class="post-tag" href="/tags/dj/">DJ</a> <a class="post-tag" href="/tags/education/">Education</a> <a class="post-tag" href="/tags/logging/">Logging</a> <a class="post-tag" href="/tags/logitech/">Logitech</a> <a class="post-tag" href="/tags/tech-debt/">Tech Debt</a> <a class="post-tag" href="/tags/west-coast-swing/">West Coast Swing</a></div></div></div><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/notes-on-test-naming/"><div class="card-body"> <span class="timeago small" > Sep 30, 2020 <i class="unloaded">2020-09-30T13:00:00-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Notes on Test Naming</h3><div class="text-muted small"><p> There are only two hard problems in programming: cache invalidation, naming things, and off-by-one errors. One of the tricky things about talking and writing about the various types of automat...</p></div></div></a></div><div class="card"> <a href="/posts/test-automation-strategy/"><div class="card-body"> <span class="timeago small" > Sep 30, 2020 <i class="unloaded">2020-09-30T13:00:00-05:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Test Automation Strategy</h3><div class="text-muted small"><p> Below are links to a series of articles I have written or plan to write on Test Automation. Enjoy! Theory: Goal and Purpose of Test Automation Test Benefit Analysis Role of Test Automation...</p></div></div></a></div><div class="card"> <a href="/posts/role-of-test-automation-in-a-ci-cd-pipeline/"><div class="card-body"> <span class="timeago small" > Nov 14, 2019 <i class="unloaded">2019-11-14T00:00:00-06:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Role of Test Automation in a CI/CD Pipeline</h3><div class="text-muted small"><p> While automated tests can be useful even when their actual execution is triggered manually, even greater benefits can be realized when we also design automation to execute them. A useful way of th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/unit-tests/" class="btn btn-outline-primary"><p>Unit Tests</p></a> <a href="/posts/tackling-tech-debt/" class="btn btn-outline-primary"><p>Tackling Tech Debt</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="font-italic text-center text-muted small"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> var options = { scriptUrl: '//dancerscode.disqus.com/embed.js', disqusConfig: function() { this.page.url = 'https://dancerscode.com/posts/integration-tests/'; this.page.identifier = '/posts/integration-tests/'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('#post-wrapper img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2023 <a href="https://twitter.com/TheDancersCode">Shawn</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy/" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-xl-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/automation/">Automation</a> <a class="post-tag" href="/tags/testing/">Testing</a> <a class="post-tag" href="/tags/blog/">Blog</a> <a class="post-tag" href="/tags/clean-code/">Clean Code</a> <a class="post-tag" href="/tags/dj/">DJ</a> <a class="post-tag" href="/tags/education/">Education</a> <a class="post-tag" href="/tags/logging/">Logging</a> <a class="post-tag" href="/tags/logitech/">Logitech</a> <a class="post-tag" href="/tags/tech-debt/">Tech Debt</a> <a class="post-tag" href="/tags/west-coast-swing/">West Coast Swing</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://dancerscode.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"><div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>{categories}</div><div><i class="fa fa-tag fa-fw"></i>{tags}</div></div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>' }); </script> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-49467963-2"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-49467963-2'); </script>
